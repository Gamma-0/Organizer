<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			/* canvas styles */
			html, body {
				font:normal normal normal 100%/1.4 tahoma, sans-serif;
				background:#f9f9f9;
				color:#000;
				height: 100vh;
				width: 100vw;
			}
			body {
				font-size:0.8rem;
				margin: 0;
				background: linear-gradient(to right , #fff3, #Fff3),
					linear-gradient(to right , #0fe9, #F559),
					linear-gradient(to bottom, #839, #F5E);
			}
			header {
				padding: 0.5rem;
				line-height: 1.5rem;
				height: 2.5rem;
				box-sizing: border-box;
				border-bottom: 1px solid transparent; /*#999;*/
				background: rgba(0, 0, 0, 0.3);
				color: #fff;
			}
			main {
				width: 100%;
				height: calc(100% - 2.5rem - 1px);
				box-sizing: border-box;
				padding: 1rem;
				display: flex;
				align-items: flex-start;
				overflow: auto;
			}

			#add-list-button {
				float: right;
				border: 1px solid #fff;
				border-radius: 5px;
				height: 1.5rem;
				width: 1.5rem;
				text-align: center;
				font-size: 1.1rem;
				line-height: 1.3rem;
				font-weight: bold;
				box-sizing: border-box;
			}
			#add-list-button:hover {
				background-color: rgba(0,0,0,0.3);
			}
			.close-item {
				font-size: 0.5rem;
			}
			.add-content {
				font-size: 0.7rem;
				transform: rotate(135deg);
			}
			.close-memolist, .close-item, .add-content, .add-item, .add-list {
				float: right;
				cursor: pointer;
			}
			.memolist {
				min-width:240px;
				width:50%;
				max-width: 360px;
				max-height: 100%;
				box-sizing: border-box;
				margin:0 0.5rem 0.5rem 0;
				padding:0.5rem;
				border:2px solid #888;
				border-radius:0.2rem;
				background:#ddd;
				color:#555;
			}
			.page-title, .memo-title, .item-title, .item-content {
				cursor: text;
			}
			.page-title {
				display: inline-block;
				font-size: 1.2rem;
			}
			.page-title input {
				font-size: inherit;
				padding: 0 0.2rem;
			}

			.memo-title {
				font-size: 1.2rem;
				/*font-weight: bold;*/
			}
			.memo-title input {
				width: calc(100% - 1.3rem); /*0.8 pour la font-size de la croix et 0.5 pour le padding avec la croix*/
			}
			.item-title input {
				width: calc(100% - 1.6rem);  /*0.5 pour la font-size de la croix, 0.7 pour le crayon et 0.4 pour le padding avec la croix*/
			}
			textarea {
				min-width: 100%;
				width: 100%;
				max-width: 100%;
			}
			input, textarea {
				box-sizing: border-box;
			}

			/* draggable targets */
			[data-draggable="target"] {
				list-style-type:none;
				max-height: calc(100vh - 8.5rem);
				overflow-y:auto;
				box-sizing: border-box;
				margin: 0;
				padding:0.5rem;
				border:2px solid transparent;
				border-radius:0.2rem;
				color:#555;
			}

			/* drop target state */
			[data-draggable="target"][aria-dropeffect="move"] {
				border-color:#68b;
				background:#fff;
			}

			/* drop target focus and dragover state */
			[data-draggable="target"][aria-dropeffect="move"]:focus,
			[data-draggable="target"][aria-dropeffect="move"].dragover {
				outline:none;
				box-shadow:0 0 0 1px #fff, 0 0 0 3px #68b;
			}

			/* draggable items */
			[data-draggable="item"] {
				display:block;
				list-style-type:none;
				margin:0 0 3px 0;
				padding:0.2rem 0.4rem;
				border-radius:0.2rem;
				line-height:1.3;

				background-color: #fff;
				border: 1px solid #999;
				cursor: grab;
			}

			/* items focus state */
			[data-draggable="item"]:focus {
				outline:none;
				box-shadow:0 0 0 2px #68b, inset 0 0 0 1px #ddd;
			}

			/* items grabbed state */
			[data-draggable="item"][aria-grabbed="true"] {
				background:#8ad;
				color:#fff;
			}
		</style>
	</head>
	<body>
		<header>
			<div class="page-title">Titre de la page</div>
			<div id="add-list-button" class="add-list">+</div> <!-- Ajouter une liste -->
		</header>
		<main id="group">
			<div class="memolist">
				<div class="close-memolist">╳</div>
				<span class="memo-title">Clique ici pour me modifier !</span>
				<ol data-draggable="target">
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<div class="add-content">✏</div>
						<span class="item-title">Modifie moi aussi !</span>
					</li>
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<div class="add-content">✏</div>
						<span class="item-title">Clique sur le crayon à droite -►</span>
					</li>
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<span class="item-title">J'ai une description !</span>
						<p class="item-content">Supprime moi en effaçant tout mon contenu ! Pour cela, faut cliquer sur moi aussi.</p>
					</li>
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<div class="add-content">✏</div>
						<span class="item-title">Supprime moi avec la croix</span>
					</li>
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<span class="item-title">Déplace moi !</span>
						<p class="item-content">Appuie sur moi avec ta souris, déplace moi et relâche le bouton quand je suis dans une des boîtes qui s'afficheront en bleu.</p>
					</li>
				</ol>
				<span class="add-item">Add item</span>
			</div>
			<div class="memolist">
				<div class="close-memolist">╳</div>
				<span class="memo-title">List 1</span>
				<ol data-draggable="target">
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<span class="item-title">Item 0</span>
						<p class="item-content">Content for item 0</p>
					</li>
					<li data-draggable="item">
						<div class="close-item">╳</div>
						<div class="add-content">✏</div>
						<span class="item-title">Efface moi, je reviendrais</span>
					</li>
				</ol>
				<span class="add-item">Add item</span>
			</div>


		</main>

	</body>
</html>

<script>

(function() {
	//exclude older browsers by the features we need them to support
	//and legacy opera explicitly so we don't waste time on a dead browser
	if (!document.querySelectorAll
		|| !('draggable' in document.createElement('span'))
		|| window.opera
	) { return; }

	//get the collection of draggable targets and add their draggable attribute
	for (var
		targets = document.querySelectorAll('[data-draggable="target"]'),
		len = targets.length,
		i = 0; i < len; i++
	) {
		targets[i].setAttribute('aria-dropeffect', 'none');
	}

	//get the collection of draggable items and add their draggable attributes
	for (var
		items = document.querySelectorAll('[data-draggable="item"]'),
		len = items.length,
		i = 0; i < len; i++
	) {
		items[i].setAttribute('draggable', 'true');
		items[i].setAttribute('aria-grabbed', 'false');
		items[i].setAttribute('tabindex', '0');
	}

	//dictionary for storing the selections data
	//comprising an array of the currently selected items
	//a reference to the selected items' owning container
	//and a refernce to the current drop target container
	var selections = {
		items	  : [],
		owner	  : null,
		droptarget : null
	};

	//function for selecting an item
	function addSelection(item) {
		//if the owner reference is still null, set it to this item's parent
		//so that further selection is only allowed within the same container
		if (!selections.owner) {
			selections.owner = item.parentNode;
		}
		//or if that's already happened then compare it with this item's parent
		//and if they're not the same container, return to prevent selection
		else if (selections.owner != item.parentNode) {
			return;
		}
		item.setAttribute('aria-grabbed', 'true');
		selections.items.push(item);
	}

	//function for unselecting an item
	function removeSelection(item) {
		item.setAttribute('aria-grabbed', 'false'); //reset this item's grabbed state

		//then find and remove this item from the existing items array
		for (var len = selections.items.length, i = 0; i < len; i++) {
			if (selections.items[i] == item) {
				selections.items.splice(i, 1);
				break;
			}
		}
	}

	//function for resetting all selections
	function clearSelections() {
		if (selections.items.length) { //if we have any selected items
			selections.owner = null; //reset the owner reference

			//reset the grabbed state on every selected item
			for (var len = selections.items.length, i = 0; i < len; i++) {
				selections.items[i].setAttribute('aria-grabbed', 'false');
			}
			selections.items = [];
		}
	}

	//shortcut function for testing whether a multiple selection modifier is pressed
	function hasModifier(e) {
		return (e.ctrlKey || e.metaKey || e.shiftKey);
	}


	//function for applying dropeffect to the target containers
	function addDropeffects() {
		//apply aria-dropeffect and tabindex to all targets apart from the owner
		for (var len = targets.length, i = 0; i < len; i++) {
			if (targets[i] != selections.owner && targets[i].getAttribute('aria-dropeffect') == 'none') {
				targets[i].setAttribute('aria-dropeffect', 'move');
				targets[i].setAttribute('tabindex', '0');
			}
		}
		//remove aria-grabbed and tabindex from all items inside those containers
		for (var len = items.length, i = 0; i < len; i++) {
			if (items[i].parentNode != selections.owner && items[i].getAttribute('aria-grabbed')) {
				items[i].removeAttribute('aria-grabbed');
				items[i].removeAttribute('tabindex');
			}
		}
	}

	//function for removing dropeffect from the target containers
	function clearDropeffects() {
		if (selections.items.length) { //if we have any selected items
			//reset aria-dropeffect and remove tabindex from all targets
			for (var len = targets.length, i = 0; i < len; i++) {
				if (targets[i].getAttribute('aria-dropeffect') != 'none') {
					targets[i].setAttribute('aria-dropeffect', 'none');
					targets[i].removeAttribute('tabindex');
				}
			}

			//restore aria-grabbed and tabindex to all selectable items
			//without changing the grabbed value of any existing selected items
			for (var len = items.length, i = 0; i < len; i++) {
				if (!items[i].getAttribute('aria-grabbed')) {
					items[i].setAttribute('aria-grabbed', 'false');
					items[i].setAttribute('tabindex', '0');
				}
				else if (items[i].getAttribute('aria-grabbed') == 'true') {
					items[i].setAttribute('tabindex', '0');
				}
			}
		}
	}

	//shortcut function for identifying an event element's target container
	function getContainer(element) {
		do {
			if (element.nodeType == 1 && element.getAttribute('aria-dropeffect')) {
				return element;
			}
		} while (element = element.parentNode);
		return null;
	}


	function makeChildDraggable(node) {
		if (node.getAttribute('draggable')) {
			return node;
		} else if (node.parentNode.getAttribute('draggable')) {
			return node.parentNode;
		}
		return node;
	}

	//mousedown event to implement single selection
	document.addEventListener('mousedown', function(e) {
		let etarget = makeChildDraggable(e.target);
		if (etarget.getAttribute('draggable')) { //if the element is a draggable item
			clearDropeffects(); //clear dropeffect from the target containers

			if (!hasModifier(e) && etarget.getAttribute('aria-grabbed') == 'false') {
				clearSelections(); //clear all existing selections
				addSelection(etarget); //then add this new selection
			}
		} else if (!hasModifier(e)) { //else [if the element is anything else] and the modifier is not pressed
			clearDropeffects(); //clear dropeffect from the target containers
			clearSelections(); //clear all existing selections
		} else { //else [if the element is anything else and the modifier is pressed]
			clearDropeffects(); //clear dropeffect from the target containers
		}
	}, false);

	//mouseup event to implement multiple selection
	document.addEventListener('mouseup', function(e) {
		//if the element is a draggable item
		//and the multipler selection modifier is pressed
		let etarget = makeChildDraggable(e.target);
		if (etarget.getAttribute('draggable') && hasModifier(e)) {
			if (etarget.getAttribute('aria-grabbed') == 'true') { // if the item is grabbed
				removeSelection(etarget); //unselect this item
				if (!selections.items.length) { //if that was the only selected item
					selections.owner = null; // reset the owner container reference
				}
			} else { // if the item is not grabbed
				addSelection(etarget);
			}
		}

	}, false);

	//dragstart event to initiate mouse dragging
	document.addEventListener('dragstart', function(e) {
		//if the element's parent is not the owner, then block this event
		if (selections.owner != e.target.parentNode) {
			e.preventDefault();
			return;
		}

		//[else] if the multiple selection modifier is pressed
		//and the item's grabbed state is currently false
		if (hasModifier(e) && e.target.getAttribute('aria-grabbed') == 'false') {
			addSelection(e.target); //add this additional selection
		}

		//we don't need the transfer data, but we have to define something
		//otherwise the drop action won't work at all in firefox
		//most browsers support the proper mime-type syntax, eg. "text/plain"
		//but we have to use this incorrect syntax for the benefit of IE10+
		e.dataTransfer.setData('text', '');
		addDropeffects(); //apply dropeffect to the target containers
	}, false);


	//keydown event to implement selection and abort
	document.addEventListener('keydown', function(e) {
		if (e.target.getAttribute('aria-grabbed')) { //if the element is a grabbable item
			//Space is the selection or unselection keystroke
			if (e.keyCode == 32) {
				//if the multiple selection modifier is pressed
				if (hasModifier(e)) {
					//if the item's grabbed state is currently true
					if (e.target.getAttribute('aria-grabbed') == 'true') {
						//if this is the only selected item, clear dropeffect
						//from the target containers, which we must do first
						//in case subsequent unselection sets owner to null
						if (selections.items.length == 1) {
							clearDropeffects();
						}
						removeSelection(e.target); //unselect this item

						//if we have any selections
						//apply dropeffect to the target containers,
						//in case earlier selections were made by mouse
						if (selections.items.length) {
							addDropeffects();
						}

						if (!selections.items.length) { //if that was the only selected item
							selections.owner = null; // reset the owner container reference
						}
					} else { // if the item is not grabbed
						addSelection(e.target); // grab it (put into selected items)
						addDropeffects(); //apply dropeffect to the target containers
					}
				}

				//else [if the multiple selection modifier is not pressed]
				//and the item's grabbed state is currently false
				else if (e.target.getAttribute('aria-grabbed') == 'false') {
					clearDropeffects(); //clear dropeffect from the target containers
					clearSelections(); //clear all existing selections
					addSelection(e.target); //add this new selection
					addDropeffects(); //apply dropeffect to the target containers
				}
				//else [if modifier is not pressed and grabbed is already true]
				else {
					addDropeffects(); //apply dropeffect to the target containers
				}
				//then prevent default to avoid any conflict with native actions
				e.preventDefault();
			}

			//Modifier + M is the end-of-selection keystroke
			if (e.keyCode == 77 && hasModifier(e)) {
				//if we have any selected items
				if (selections.items.length) {
					//apply dropeffect to the target containers
					//in case earlier selections were made by mouse
					addDropeffects();

					//if the owner container is the last one, focus the first one
					if (selections.owner == targets[targets.length - 1]){
						targets[0].focus();
					} else {//else [if it's not the last one], find and focus the next one
						for (var len = targets.length, i = 0; i < len; i++) {
							if (selections.owner == targets[i]) {
								targets[i + 1].focus();
								break;
							}
						}
					}
				}

				//then prevent default to avoid any conflict with native actions
				e.preventDefault();
			}
		}

		//Escape is the abort keystroke (for any target element)
		if (e.keyCode == 27) {
			//if we have any selected items
			if (selections.items.length) {
				clearDropeffects(); //clear dropeffect from the target containers
				//then set focus back on the last item that was selected, which is
				//necessary because we've removed tabindex from the current focus
				selections.items[selections.items.length - 1].focus();
				clearSelections(); //clear all existing selections
				//but don't prevent default so that native actions can still occur
			}
		}
	}, false);

	//related variable is needed to maintain a reference to the
	//dragleave's relatedTarget, since it doesn't have e.relatedTarget
	var related = null;

	//dragenter event to set that variable
	document.addEventListener('dragenter', function(e) {
		related = e.target;
	}, false);

	//dragleave event to maintain target highlighting using that variable
	document.addEventListener('dragleave', function(e) {
		//get a drop target reference from the relatedTarget
		var droptarget = getContainer(related);
		//if the target is the owner then it's not a valid drop target
		if (droptarget == selections.owner) {
			droptarget = null;
		}
		//if the drop target is different from the last stored reference
		//(or we have one of those references but not the other one)
		if (droptarget != selections.droptarget) {
			//if we have a saved reference, clear its existing dragover class
			if (selections.droptarget) {
				selections.droptarget.className = selections.droptarget.className.replace(/ dragover/g, '');
			}
			//apply the dragover class to the new drop target reference
			if (droptarget) {
				droptarget.className += ' dragover';
			}
			selections.droptarget = droptarget; //then save that reference for next time
		}
	}, false);

	//dragover event to allow the drag by preventing its default
	document.addEventListener('dragover', function(e) {
		//if we have any selected items, allow them to be dragged
		if (selections.items.length) {
			e.preventDefault();
		}
	}, false);

	//dragend event to implement items being validly dropped into targets,
	//or invalidly dropped elsewhere, and to clean-up the interface either way
	document.addEventListener('dragend', function(e) {
		//if we have a valid drop target reference
		//(which implies that we have some selected items)
		if (selections.droptarget) {
			//append the selected items to the end of the target container
			for (var len = selections.items.length, i = 0; i < len; i++) {
				selections.droptarget.appendChild(selections.items[i]);
			}
			e.preventDefault(); //prevent default to allow the action
		}

		if (selections.items.length) { //if we have any selected items
			clearDropeffects(); //clear dropeffect from the target containers
			if (selections.droptarget) { //if we have a valid drop target reference
				clearSelections(); //reset the selections array
				//reset the target's dragover class
				selections.droptarget.className = selections.droptarget.className.replace(/ dragover/g, '');
				selections.droptarget = null; //reset the target reference
			}
		}
	}, false);

	//keydown event to implement items being dropped into targets
	document.addEventListener('keydown', function(e) {
		//if the element is a drop target container
		if (e.target.getAttribute('aria-dropeffect')) {
			//Enter or Modifier + M is the drop keystroke
			if (e.keyCode == 13 || (e.keyCode == 77 && hasModifier(e))) {
				//append the selected items to the end of the target container
				for(var len = selections.items.length, i = 0; i < len; i++) {
					e.target.appendChild(selections.items[i]);
				}
				//clear dropeffect from the target containers
				clearDropeffects();
				//then set focus back on the last item that was selected, which is
				//necessary because we've removed tabindex from the current focus
				selections.items[selections.items.length - 1].focus();
				clearSelections(); //reset the selections array
				e.preventDefault(); //prevent default to to avoid any conflict with native actions
			}
		}
	}, false);


	var defaultText = null;
	function defaultLanguage(lang) {
		switch (lang) {
			case "FR":
				defaultText = {
					memotitle: "Titre de liste",
					itemtitle: "Titre de l'élément",
					itemcontent: "Du contenu ou une description",
					additem: "Ajouter un élément"
				}
				break;
			case "EN":
			default:
				defaultText = {
					memotitle: "List title",
					itemtitle: "Item title",
					itemcontent: "Some description or content",
					additem: "Add item"
				}
		}
	}
	defaultLanguage();

	/* Function to easily add component */
	function appendChildAddContentToNode(node) {
		let addcontent = document.createElement("div");
		addcontent.className = "add-content";
		addcontent.appendChild(document.createTextNode("✏"));
		node.appendChild(addcontent);
	}

	function appendChildItemToNode(target) {
		let item = document.createElement("li");
		item.setAttribute("data-draggable","item");

		let itemtitle = document.createElement("span");
		itemtitle.className = "item-title";
		itemtitle.appendChild(document.createTextNode(defaultText.itemtitle));

		let closeitem = document.createElement("div");
		closeitem.className = "close-item";
		closeitem.appendChild(document.createTextNode("╳"));

		item.appendChild(closeitem);
		appendChildAddContentToNode(item);
		item.appendChild(itemtitle);
		target.appendChild(item);

		item.setAttribute('draggable', 'true');
		item.setAttribute('aria-grabbed', 'false');
		item.setAttribute('tabindex', '0');
		//items = document.querySelectorAll('[data-draggable="item"]');
	}

	function appendChildMemoListToNode(node) {
		let memolist = document.createElement("div");
		memolist.className = "memolist";

		let closememolist = document.createElement("div");
		closememolist.className = "close-memolist";
		closememolist.appendChild(document.createTextNode("╳"));

		let memotitle = document.createElement("span");
		memotitle.className = "memo-title";
		memotitle.appendChild(document.createTextNode(defaultText.memotitle));

		let target = document.createElement("ol");
		target.setAttribute("data-draggable","target");

		let additem = document.createElement("span");
		additem.className = "add-item";
		additem.appendChild(document.createTextNode(defaultText.additem));

		memolist.appendChild(closememolist);
		memolist.appendChild(memotitle);
		memolist.appendChild(target);
		memolist.appendChild(additem);
		node.appendChild(memolist);

		target.setAttribute('aria-dropeffect', 'none');
	}

	var currentInput = {
		node: null,
		content: ''
	};
	document.addEventListener('click', function(e) { //addItem(e) {
		if (e.target.className == "add-content") {
			let memolist = e.target.parentNode;

			let itemcontent = document.createElement("p");
			itemcontent.className = "item-content";
			itemcontent.appendChild(document.createTextNode(defaultText.itemcontent));

			memolist.appendChild(itemcontent);
			memolist.removeChild(e.target);
		}
		else if (e.target.className == "add-item") {
			let node = e.target.parentNode.querySelectorAll('[data-draggable="target"]')[0];
			appendChildItemToNode(node);
			items = document.querySelectorAll('[data-draggable="item"]');
		}
		else if (e.target.className == "add-list") {
			let main = document.getElementById("group");
 			appendChildMemoListToNode(main);
			targets = document.querySelectorAll('[data-draggable="target"]');
		}
		else if (e.target.className == "close-memolist" || e.target.className == "close-item") {
			let memolist = e.target.parentNode;
			memolist.parentNode.removeChild(memolist);
		}

		else if ((e.target.className == "page-title"
				|| e.target.className == "memo-title"
				|| e.target.className == "item-title"
				|| e.target.className == "item-content")
				&& currentInput.node !== e.target)
		{
			let text = e.target.firstChild;//.style.display = "none";
			let input = null;
			if (e.target.className == "item-content") {
				input = document.createElement("textarea");
				input.value = text.data;
			} else {
				input = document.createElement("input");
				input.setAttribute("type", "text");
				input.setAttribute("value", text.data);
			}
			if (e.target.className == "item-title" || e.target.className == "item-content")
				e.target.parentNode.setAttribute('draggable', 'false');

			e.target.removeChild(text);
			e.target.appendChild(input);
			currentInput.node = e.target;
			currentInput.content = input.value;
		}
	}, false);


	function textFocus (e) {
		if (currentInput.node !== null && (e.target !== currentInput.node && e.target !== currentInput.node.firstChild)) {
			let input = currentInput.node.firstChild;
			let text = input.value;

			if (currentInput.node.className == "item-title" || currentInput.node.className == "item-content")
				currentInput.node.parentNode.setAttribute('draggable', 'true');

			// TODO!!!!!
			if (text == ''){
				if (currentInput.node.className == "item-content") {
					appendChildAddContentToNode(currentInput.node.parentNode);
					currentInput.node.parentNode.removeChild(currentInput.node);
				}
				else {//if (currentInput.node.className == "item-title" || currentInput.node.className == "memo-title" || currentInput.node.className == "page-title") {
					currentInput.node.appendChild(document.createTextNode(currentInput.content));
					currentInput.node.removeChild(input);
				}
			} else {
				currentInput.node.appendChild(document.createTextNode(text));
				currentInput.node.removeChild(input);
			}

			currentInput.node = null;
			currentInput.content = '';
		}
	}
	document.addEventListener('mousedown', textFocus, false);
	document.addEventListener('keydown', textFocus, false);
	document.addEventListener('keyup', textFocus, false);

})();
</script>
